using System.Collections.Generic;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc.Testing;
using Microsoft.AspNetCore.WebUtilities;
using Backend.Services;
using Xunit;
using SafeRide.src.Models;
using SafeRide.src.Services;
using Newtonsoft.Json;
using System;
using SafeRide.src.DataAccess;
using Xunit.Abstractions;
using Microsoft.VisualStudio.Web.CodeGeneration.Design;

namespace SRUnitTests
{

    public class CustomWebAppFactory : WebApplicationFactory<Program>
    {
        private readonly string _environment;

        public CustomWebAppFactory(string environment = "Development")
        {
            _environment = environment;
        }
    }

    public class ExcludeHazardUnitTests
    {

        private readonly ITestOutputHelper output;

        public ExcludeHazardUnitTests(ITestOutputHelper output)
        {
            this.output = output;
        }


        // two random step coordinates taken from the route response used in this UnitTest
        // the actual actual distance between them is 10.820 miles (17413.807 meters)
        // calculated using "https://www.cqsrg.org/tools/GCDistance/"
        [Theory]
        [InlineData(-121.5519422062582, 37.77904292167199, -121.39962701098186, 37.711694879433495, 8046.72, false)] // test if the target coord is within a 5 mile radius of the center 
        [InlineData(-121.5519422062582, 37.77904292167199, -121.39962701098186, 37.711694879433495, 24140.2, true)] // test if the target coord is within a 15 mile radius of the center 
        public void IsInsideRadius(double centerY, double centerX, double targetY, double targetX, double radius, bool expected)
        {
            /// coordinates from mapbox come in the form (<long> (y),<lat> (x)), so they must be inverted when calling the function
			ExcludeHazardService excludeService = new ExcludeHazardService();
            var actual = excludeService.IsInside(centerY, centerX, targetY, targetX, radius);

            Assert.Equal(actual, expected);
        }


        [Fact]
        public async Task FindSearchCoordinates()
        {
            HttpClient client = new HttpClient();
            HttpResponseMessage response = await client.GetAsync("https://api.mapbox.com/directions/v5/mapbox/driving/-73.832902%2C40.736744%3B-73.834413%2C40.736805?alternatives=true&geometries=geojson&language=en&overview=simplified&steps=true&access_token=pk.eyJ1IjoiY29saW5jcmVhc21hbiIsImEiOiJjbDIxbGhnZ2QxMW1pM2Jwamp4YW42M25zIn0.WJD2zPxATbnf2utML0OOCQ");



            response.EnsureSuccessStatusCode();
            string jsonResponse = await response.Content.ReadAsStringAsync();

            ParseResponseService? ParseResponseService = new ParseResponseService();
            ParseResponseService.ParseResponse(jsonResponse);
            var firstRoute = ParseResponseService.GetRoute(0);

            ExcludeHazardService? excludeHazardService = new ExcludeHazardService();

            // all points of the route generated by the hard coded request URL  are within a single search radius
            // in this case, FindSearchCoordinates should only return one search coordinate where the route starts
            var expected = new Dictionary<double, double>()
            {
                [-73.832902] = 40.736744
            };
            var actual = excludeHazardService.FindSearchCoordinates(firstRoute);

            Assert.Equal(expected, actual);
        }


        [Theory]
        [InlineData("0", 4)] // expecting 5 "Accident" hazards within radi'us
        [InlineData("1", 1)] // expecting 1 "Obstruction" hazard within radius
        [InlineData("1", 3)] // expecting 3 "BikeLane" hazards within radius
        [InlineData("3", 4)] // expecting 4 "Vehicle" hazards within radius
        [InlineData("4", 0)] // expecting 0 "Closure" hazards within radius
        public async Task GetByTypeInRadius(string hazardTypes, int expected)
        {
            await using var application = new CustomWebAppFactory();
            using var client = application.CreateClient();
             HttpResponseMessage response = await client.GetAsync("https://api.mapbox.com/directions/v5/mapbox/driving/-74.002917%2C40.73992%3B-74.012917%2C40.73992?alternatives=true&geometries=geojson&language=en&overview=simplified&steps=true&access_token=pk.eyJ1IjoiY29saW5jcmVhc21hbiIsImEiOiJjbDIxbGhnZ2QxMW1pM2Jwamp4YW42M25zIn0.WJD2zPxATbnf2utML0OOCQ");
            // extract route from the response
            response.EnsureSuccessStatusCode();
            string jsonResponse = await response.Content.ReadAsStringAsync();
            ParseResponseService? ParseResponseService = new ParseResponseService();
            ParseResponseService.ParseResponse(jsonResponse);
            var firstRoute = ParseResponseService.GetRoute(0);

            var request = new HttpRequestMessage(HttpMethod.Post, "api/hazard/exclude");

            request.Headers.Add(jsonResponse, hazardTypes);
            // use for troubleshooting incorrect coordinate queries
            using var actualHazards = await client.SendAsync(request);

            // check the total number of hazards found along the route
            int actual = actualHazards.ToString().Length;
            Assert.Equal(expected, actual);

        }
    }
}





         //output.WriteLine("\nActual coordinates queried for hazards with type {0} in radius:", hazardType);
            //foreach (KeyValuePair<double, double> kvp in actualHazards)
            //{
            //    output.WriteLine("Key = {0}, Value = {1}", kvp.Key, kvp.Value);
            //}

            // use to show exact query results when troubleshooting DAO method
            //  Dictionary<double, double> expectedAccidentHazards = new Dictionary<double, double>()
            //  {
            //      [-73.99015] = 40.732204,
            //      [-73.990042] = 40.733456,
            //      [-73.990014] = 40.732818,
            //      [-73.989869] = 40.732689,
            //      [-73.990042] = 40.732689,

            //  };
            ////  Assert.NotStrictEqual(expectedHazards, actual);
            //  Assert.Equal(expectedAccidentHazards, actualHazards);
